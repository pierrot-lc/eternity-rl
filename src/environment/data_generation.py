"""The goal of this module is to generate the data for the model.

The data is generated using the following steps:
    1. Generate a random instance of the environment in a perfect state.
    2. Randomly select two tiles, roll and swap them.
    3. Repeat step 2 for a given number of iterations.
    4. Save the action taken and the resulting state.
"""

import numpy as np

from .gym import EAST, NORTH, SOUTH, WALL_ID, WEST, EternityEnv


def generate_perfect_instance(
    size: int,
    n_classes: int,
    seed: int = 0,
) -> np.ndarray:
    """Generate a perfect instance of the environment.
    A perfect instance is an instance where all the tiles are
    correctly placed.
    """
    rng = np.random.default_rng(seed)
    instance = np.zeros((4, size, size), dtype=np.int32)

    def fill_tile(instance: np.ndarray, coords: tuple[int, int]):
        """Fill the given tile with random classes.
        Takes into account the walls at the borders.
        """
        y, x = coords

        # South filling.
        if y == 0:  # The tile is at the bottom of the map.
            instance[SOUTH, y, x] = WALL_ID
        else:  # Copy from the tile below.
            instance[SOUTH, y, x] = instance[NORTH, y - 1, x]

        # West filling.
        if x == 0:
            instance[WEST, y, x] = WALL_ID
        else:
            instance[WEST, y, x] = instance[EAST, y, x - 1]

        # North filling.
        if y == size - 1:
            instance[NORTH, y, x] = WALL_ID
        else:
            instance[NORTH, y, x] = rng.integers(1, n_classes)

        # East filling.
        if x == size - 1:
            instance[EAST, y, x] = WALL_ID
        else:
            instance[EAST, y, x] = rng.integers(1, n_classes)

    # Generate the instance from the bottom left to the top right.
    for y in range(size):
        for x in range(size):
            fill_tile(instance, (y, x))

    return instance


def generate_sample(
    size: int,
    n_classes: int,
    n_steps: int,
    seed: int = 0,
) -> tuple[np.ndarray, np.ndarray]:
    """Generate the data for the model.
    The data is generated by generating a perfect instance of the
    environment and randomly swapping two tiles.
    """
    rng = np.random.default_rng(seed)
    instance = generate_perfect_instance(size, n_classes, seed=seed)
    env = EternityEnv(instance)
    instances = np.zeros((n_steps, 4, size, size), dtype=np.int32)

    # Sample random actions.
    swaps = rng.integers(0, size**2, size=(n_steps, 2))
    rolls = rng.integers(0, 4, size=(n_steps, 2))

    actions = np.zeros((n_steps, 4), dtype=np.int32)
    actions[:, ::2] = swaps
    actions[:, 1::2] = rolls

    # Take the actions.
    for step_id, action in enumerate(actions):
        env.step(action)
        instances[step_id] = env.render()

    # Revert the actions.
    rolls = (np.flip(rolls, axis=1) * -1) % 4
    actions[:, ::2] = swaps
    actions[:, 1::2] = rolls
    actions = np.flip(actions, axis=0)

    # Revert the instances.
    instances = np.flip(instances, axis=0)

    return instances, actions
